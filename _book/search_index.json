[
["index.html", "A glimpse of GIS and Remote Sensing with R Prerequisites", " A glimpse of GIS and Remote Sensing with R Masumbuko Semba 2019-04-21 Prerequisites This book assumes you have some knowledge of R. If you’ve never used R before, or need a refresher, start with our Introduction to R for Geospatial Data lesson.This book also assumes you have some knowledge of geospatial data types and common file formats. If you have never worked with geospatial data before, or need a refresher, start with our Introduction to Geospatial Concepts lesson. "],
["sources.html", "Sources", " Sources https://geocompr.robinlovelace.net/adv-map.html#inset-maps https://mgimond.github.io/Spatial/good-map-making-tips.html https://r4ds.had.co.nz/graphics-for-communication.html "],
["intro.html", "Chapter 1 Introduction to Spatial Analysis", " Chapter 1 Introduction to Spatial Analysis The goal of this book is to provide an introduction to R for learners working with geospatial data. It is intended as a pre-requisite for the R for Raster and Vector Data for learners who have no prior experience using R. This book focus on the following topics: Working with R in the RStudio GUI Project management and file organization Importing data into R Introduction to R’s core data types and data structures Manipulation of data frames (tabular data) in R Introduction to visualization Writing data to a file. "],
["raster.html", "Chapter 2 Raster Data 2.1 Introduction to Raster data 2.2 Assign projection and Reproject Raster Data in R 2.3 Raster resolution 2.4 Raster Calculation 2.5 Multi-bands satellite imagery 2.6 Manipulate raster 2.7 Raster time series data 2.8 comparing NDVI from Two different sites", " Chapter 2 Raster Data Questions what is a raster dataset? What tools/functions are used to import raster in R? How to I work with and plot raster data in R How missing or bad data in R are handled with R Objectives Describe the fundamental attributes of a raster dataset Explore raster attributtes and metadata Import raster dataset into R workspace visualize raster object Distinguish single versus multi-bands rasters 2.1 Introduction to Raster data This this section introduce you to the fundamental principles, packages and metadata/raster attributes that are needed to work with raster data in R. The section discuss some of the core metadata elements that you need to understand to work with rasters in R, including CRS and resolution. Furthermore, missing and bad data values stored in raster will be explored and techniques to handles these elements will be illustrated. The book use several packages including the tidyverse ecosystem (Wickham 2017)—with popular packages like the ggplot2(Wickham 2016) and dplyr (Wickham et al. 2019). The widely used packages for handling raster and vector data like raster (Hijmans 2019), sp(Bivand, Pebesma, and Gomez-Rubio 2013), sf (Pebesma 2018) and rgdal (Bivand, Keitt, and Rowlingson 2019) make core tools in this book. R needs these packages imported into the environment to use their functions, which can easily done with the require() function. require(sf) require(sp) require(raster) require(tidyverse) require(metR) 2.1.1 GeoTiff A popular public domain raster data format is the GeoTIFF format. If maximum portability and platform independence is important, this file format may be a good choice. 2.1.2 Explore the raster attribute One of the common raster file is the *GeoTiff** that embed tags of metadata information bout the raster file. This metadata provide the information of the file and hence help us understand the internal structure of the file. This information can be accessed with the GDALinfo() function (Bivand, Keitt, and Rowlingson 2019). Looking at the metadata help us have a glimpse of the file before even the file is imported into the workspace. rgdal::GDALinfo(&quot;e:/GIS/Tanzania spatial data Bank/Lake_Tanganyika_Bathymetry/Lake_Tanganyika_Bathymetry/grid/tanganyika_dbm (2013_10_23 20_44_28 UTC).tif&quot;) ## rows 6589 ## columns 2575 ## bands 1 ## lower left origin.x 29.05769 ## lower left origin.y -8.811174 ## res.x 0.000833 ## res.y 0.000833 ## ysign -1 ## oblique.x 0 ## oblique.y 0 ## driver GTiff ## projection +proj=longlat +datum=WGS84 +no_defs ## file e:/GIS/Tanzania spatial data Bank/Lake_Tanganyika_Bathymetry/Lake_Tanganyika_Bathymetry/grid/tanganyika_dbm (2013_10_23 20_44_28 UTC).tif ## apparent band summary: ## GDType hasNoDataValue NoDataValue blockSize1 blockSize2 ## 1 Float32 TRUE -3.402823e+38 128 128 ## apparent band statistics: ## Bmin Bmax Bmean Bsd ## 1 -1500 0 -607.0582 427.0307 ## Metadata: ## AREA_OR_POINT=Area 2.1.3 Read a GeoTIFF raster data Once you have a glimpse of the information of the raster—for example the above information show that the tiff contain elevation values and provide the summary statistics of the elevation with minimum value of 0 and maximum value of 1500 with average of 607. It also show the geographical extent with minimum longitude o 29.05769 and maximul latitude of -8.811174. Furthermore, the metadata tell us that the file is projected with World Geodetic System (WGS84) and the cell has a horizontal resolution of 0.000833 degree. Once we know this information, we can read the file with the raster function of raster package (Hijmans 2019) For this example, we use the bathmetry information of Lake Tanganyika found in Africa. It the world’s longest freshwater lake, the second largest largest by volume, and the second deepest lake in the world after lake Baikal in Siberia (“Lake Tanyanyika,” n.d.). lt.bath = raster(&quot;e:/GIS/Tanzania spatial data Bank/Lake_Tanganyika_Bathymetry/Lake_Tanganyika_Bathymetry/grid/tanganyika_dbm (2013_10_23 20_44_28 UTC).tif&quot;) We can summary function to look at the statistics of the bathmetry of this lake. Looking at the descriptive statistics, we notice that the lake has the depth range from 0 to 1500 m and there is no cell without a value. lt.bath %&gt;% summary() ## Warning in .local(object, ...): summary is an estimate based on a sample of 1e+05 cells (0.59% of all cells) ## tanganyika_dbm_.2013_10_23_20_44_28_UTC. ## Min. -1500.0000 ## 1st Qu. -952.9855 ## Median -529.7043 ## 3rd Qu. -250.4943 ## Max. 0.0000 ## NA&#39;s 0.0000 There are times when a raster file does not show the summary statistics. When this occurs you can manually calculate the cell values using the setMinMax() function. lt.bath %&gt;% setMinMax() ## class : RasterLayer ## dimensions : 6589, 2575, 16966675 (nrow, ncol, ncell) ## resolution : 0.000833, 0.000833 (x, y) ## extent : 29.05769, 31.20266, -8.811174, -3.322537 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## data source : e:/GIS/Tanzania spatial data Bank/Lake_Tanganyika_Bathymetry/Lake_Tanganyika_Bathymetry/grid/tanganyika_dbm (2013_10_23 20_44_28 UTC).tif ## names : tanganyika_dbm_.2013_10_23_20_44_28_UTC. ## values : -1500, 0 (min, max) 2.1.4 View Raster Coordinate Reference System A spatial reference system (SRS) or coordinate referene system (CRS) is a coordinate-based local, regional or global system used to locate geographical entities (“Coordinate Reference System,” n.d.). A spatial reference system defines a specific map projection and transofrmation betweeen diffferent spatial reference systems. We can look the embedded CRS in the raster file with teh crs() function from raster package. lt.bath %&gt;% crs() ## CRS arguments: ## +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 We notice that the raster file is projected in Word Geodetic System of 1984 (WGS84). In summary the projection +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 tell us as follows: proj=longlat: the projectionis in longitude and latitude decimal degrees datum=WGS84: the datum is WGS84 and it referes to the 0,0 refereence for the coordinate system used in the projection ellps=WGS84: the ellipsoidd—how the earth’s roundness is calculated for the data is WGS84 2.1.5 Dealing with missing data in raster Raster data often has NoData value to represent the absence of data. This is a value assigned to pixels where data is missing or absent. The raster comes with a ract1 contain both the elevation and bathmetry information. But if you want to plot area contour from the coastline offshore, you will need to remove elevation information and this is when you assign the elevation pixel with the NoData value. The values that is conventionally used to represent missing data varies by ther raster data type. For example, for floating points rasters, the figure -3.4e+38 is commonly used while for integers a figure -9999 is common. However, when raster are imported, R assigns these missing cell with NA. tz.bath = raster(&quot;e:/GIS/ROADMAP/Etopo 1/Tanzania_etopo1/tanz1_-3432.asc&quot;) tz.bath %&gt;% summary() ## Warning in .local(object, ...): summary is an estimate based on a sample of 1e+05 cells (15.22% of all cells) ## tanz1_.3432 ## Min. -4890 ## 1st Qu. -3515 ## Median -290 ## 3rd Qu. 614 ## Max. 5637 ## NA&#39;s 0 2.2 Assign projection and Reproject Raster Data in R Sometimes we encounter raster datasets that do not “line up” when plotted or analyzed. Rasters that don’t line up are most often in different Coordinate Reference Systems (CRS). This section explains how to deal with rasters in different, known CRSs. It will walk though reprojecting rasters in R using the projectRaster() function in the raster package. We can assess the projection of the two raster data we loaded earlier with the crs() function from raster package. Let’s begin with the bathmetry raster of Lake Tanganyika crs(lt.bath) ## CRS arguments: ## +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 We notice that the bathmetry raster of Lake Tanganyika has defined coordinate reference system—WGS84. let us also check the bathmetry data from the coastal water of Tanzania using the same crs() function. crs(tz.bath) ## CRS arguments: NA Unfortunately, the bathmetry raster of coastal water of Tanzania lack the coordinate reference systm—this idicate that the projection is not defined yet. fortunate, raster package has projectRaster() function that allows to reproject raster without defined CRS or reproject a raster from one CRS into another. Since the lt.bath has the projection, we can use its projection to define the missing coordinate system in tz.bath raster file. Because we need to define a projection of the missing raster, we simply use the crs() function to copy the projection of lt.bath into the tz.bath as the code block illustrate crs(tz.bath) = crs(lt.bath) We can check the coordinate of the two files if they are correct crs(tz.bath); crs(lt.bath) ## CRS arguments: ## +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## CRS arguments: ## +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 Since we know that the coastal water of Tanzania lies at zone 37 south, we can simply assign the appropriate projection and then transform the bathmetry from WGS84 to UTM zone 37 south. Since we know the text of the zone, let us define it tzutm = &quot;+proj=utm +zone=37 +south +datum=WGS84 +units=m +no_defs&quot; We then use the projectExtent() function to transform the CRS from WGS84 to UTM Zone 37 south tz.bath.utm = projectExtent(tz.bath, tzutm) Then check the files projections. Instead of using the crs() to assess the type of projection, we use the projection() function instead. tz.bath %&gt;% projection(asText = F); tz.bath.utm %&gt;% projection(asText = F) ## CRS arguments: ## +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## CRS arguments: ## +proj=utm +zone=37 +south +datum=WGS84 +units=m +no_defs ## +ellps=WGS84 +towgs84=0,0,0 2.3 Raster resolution Let’s next have a look at the resolution of reprojected tz.bath.utm and the tz.bath files. tz.bath.utm %&gt;% res();tz.bath %&gt;% res() ## [1] 1859.258 1860.036 ## [1] 0.01666667 0.01666667 We notice that the horizontal resolution of projected utm tz.bath.utm file is given in meters of 1859.258 by 1860.036. But the the wgs84 tz.bath is given in degree of 0.01666667 by 0.01666667. Therefore, depending on how you intend to use the raster in analysis and mapping, you will find yourself resonate between geographical coordianate system (WGS) and Universal Transeverse Mercator (UTM). The former is in degree while the later is in meters. 2.4 Raster Calculation Often times we want to perform calculations on two or more rasters to create a new output raster. For example, if we are interested in mapping the heights of trees across an entire field site, we might want to calculate the difference between the Digital Surface Model (DSM, tops of trees) and the Digital Terrain Model (DTM, ground level). The resulting dataset is referred to as a Canopy Height Model (CHM) and represents the actual height of trees, buildings, etc. with the influence of ground elevation removed. 2.5 Multi-bands satellite imagery High resolution digital globe multispectral image. Let us explore the image first rgdal::GDALinfo(&quot;e:/GIS/trevor/053575070010_01/053575070010_01_P001_MUL/14AUG19082006-M2AS-053575070010_01_P001.TIF&quot;) ## rows 5013 ## columns 2340 ## bands 8 ## lower left origin.x 431076 ## lower left origin.y 7020086 ## res.x 2 ## res.y 2 ## ysign -1 ## oblique.x 0 ## oblique.y 0 ## driver GTiff ## projection +proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs ## file e:/GIS/trevor/053575070010_01/053575070010_01_P001_MUL/14AUG19082006-M2AS-053575070010_01_P001.TIF ## apparent band summary: ## GDType hasNoDataValue NoDataValue blockSize1 blockSize2 ## 1 UInt16 FALSE 0 224 2340 ## 2 UInt16 FALSE 0 224 2340 ## 3 UInt16 FALSE 0 224 2340 ## 4 UInt16 FALSE 0 224 2340 ## 5 UInt16 FALSE 0 224 2340 ## 6 UInt16 FALSE 0 224 2340 ## 7 UInt16 FALSE 0 224 2340 ## 8 UInt16 FALSE 0 224 2340 ## apparent band statistics: ## Bmin Bmax Bmean Bsd ## 1 214 1012 241.0628 6.579988 ## 2 172 1235 203.5383 11.027946 ## 3 170 2047 240.6267 24.320807 ## 4 101 2047 212.6599 37.599717 ## 5 49 1528 128.3042 32.559744 ## 6 100 2047 306.6574 67.605365 ## 7 56 1729 353.3486 106.036615 ## 8 32 1723 333.0844 98.604913 ## Metadata: ## AREA_OR_POINT=Area ## TIFFTAG_COPYRIGHT=(C) COPYRIGHT 2014 DigitalGlobe, Inc., Longmont CO USA 80503 ## TIFFTAG_DATETIME=2014:08:19 12:17:12 ## TIFFTAG_IMAGEDESCRIPTION={ ## bandList = ## [ ## 6; ## 2; ## 3; ## 7; ## 4; ## 8; ## 5; ## 9; ## ] ## } ## TIFFTAG_MAXSAMPLEVALUE=2047 ## TIFFTAG_MINSAMPLEVALUE=0 dg = raster(&quot;e:/GIS/trevor/053575070010_01/053575070010_01_P001_MUL/14AUG19082006-M2AS-053575070010_01_P001.TIF&quot;) When we explore the raster file, it tell that the class is raster layer and it has eight bands with spatial resolution of 2 meters. dg ## class : RasterLayer ## band : 1 (of 8 bands) ## dimensions : 5013, 2340, 11730420 (nrow, ncol, ncell) ## resolution : 2, 2 (x, y) ## extent : 431076, 435756, 7020086, 7030112 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## data source : e:/GIS/trevor/053575070010_01/053575070010_01_P001_MUL/14AUG19082006-M2AS-053575070010_01_P001.TIF ## names : X14AUG19082006.M2AS.053575070010_01_P001 ## values : 214, 1012 (min, max) Check for geographical coordinate system dg %&gt;% projection() ## [1] &quot;+proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0&quot; check for the resolution res(dg) ## [1] 2 2 2.5.1 Rater Stacks The multi-bands raster in R are handled easily with the stack() function, which bling all bands of multi-band raster dg.bands = stack(&quot;e:/GIS/trevor/053575070010_01/053575070010_01_P001_MUL/14AUG19082006-M2AS-053575070010_01_P001.TIF&quot;) We then preview the attributes embedded in the stacked raster object dg.bands ## class : RasterStack ## dimensions : 5013, 2340, 11730420, 8 (nrow, ncol, ncell, nlayers) ## resolution : 2, 2 (x, y) ## extent : 431076, 435756, 7020086, 7030112 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## names : X14AUG190//_01_P001.1, X14AUG190//_01_P001.2, X14AUG190//_01_P001.3, X14AUG190//_01_P001.4, X14AUG190//_01_P001.5, X14AUG190//_01_P001.6, X14AUG190//_01_P001.7, X14AUG190//_01_P001.8 ## min values : 214, 172, 170, 101, 49, 100, 56, 32 ## max values : 1012, 1235, 2047, 2047, 1528, 2047, 1729, 1723 We can view the attributes of each band in the stack with a single output using the $ operator and call the layer dg.bands@layers ## [[1]] ## class : RasterLayer ## band : 1 (of 8 bands) ## dimensions : 5013, 2340, 11730420 (nrow, ncol, ncell) ## resolution : 2, 2 (x, y) ## extent : 431076, 435756, 7020086, 7030112 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## data source : e:/GIS/trevor/053575070010_01/053575070010_01_P001_MUL/14AUG19082006-M2AS-053575070010_01_P001.TIF ## names : X14AUG19082006.M2AS.053575070010_01_P001.1 ## values : 214, 1012 (min, max) ## ## ## [[2]] ## class : RasterLayer ## band : 2 (of 8 bands) ## dimensions : 5013, 2340, 11730420 (nrow, ncol, ncell) ## resolution : 2, 2 (x, y) ## extent : 431076, 435756, 7020086, 7030112 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## data source : e:/GIS/trevor/053575070010_01/053575070010_01_P001_MUL/14AUG19082006-M2AS-053575070010_01_P001.TIF ## names : X14AUG19082006.M2AS.053575070010_01_P001.2 ## values : 172, 1235 (min, max) ## ## ## [[3]] ## class : RasterLayer ## band : 3 (of 8 bands) ## dimensions : 5013, 2340, 11730420 (nrow, ncol, ncell) ## resolution : 2, 2 (x, y) ## extent : 431076, 435756, 7020086, 7030112 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## data source : e:/GIS/trevor/053575070010_01/053575070010_01_P001_MUL/14AUG19082006-M2AS-053575070010_01_P001.TIF ## names : X14AUG19082006.M2AS.053575070010_01_P001.3 ## values : 170, 2047 (min, max) ## ## ## [[4]] ## class : RasterLayer ## band : 4 (of 8 bands) ## dimensions : 5013, 2340, 11730420 (nrow, ncol, ncell) ## resolution : 2, 2 (x, y) ## extent : 431076, 435756, 7020086, 7030112 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## data source : e:/GIS/trevor/053575070010_01/053575070010_01_P001_MUL/14AUG19082006-M2AS-053575070010_01_P001.TIF ## names : X14AUG19082006.M2AS.053575070010_01_P001.4 ## values : 101, 2047 (min, max) ## ## ## [[5]] ## class : RasterLayer ## band : 5 (of 8 bands) ## dimensions : 5013, 2340, 11730420 (nrow, ncol, ncell) ## resolution : 2, 2 (x, y) ## extent : 431076, 435756, 7020086, 7030112 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## data source : e:/GIS/trevor/053575070010_01/053575070010_01_P001_MUL/14AUG19082006-M2AS-053575070010_01_P001.TIF ## names : X14AUG19082006.M2AS.053575070010_01_P001.5 ## values : 49, 1528 (min, max) ## ## ## [[6]] ## class : RasterLayer ## band : 6 (of 8 bands) ## dimensions : 5013, 2340, 11730420 (nrow, ncol, ncell) ## resolution : 2, 2 (x, y) ## extent : 431076, 435756, 7020086, 7030112 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## data source : e:/GIS/trevor/053575070010_01/053575070010_01_P001_MUL/14AUG19082006-M2AS-053575070010_01_P001.TIF ## names : X14AUG19082006.M2AS.053575070010_01_P001.6 ## values : 100, 2047 (min, max) ## ## ## [[7]] ## class : RasterLayer ## band : 7 (of 8 bands) ## dimensions : 5013, 2340, 11730420 (nrow, ncol, ncell) ## resolution : 2, 2 (x, y) ## extent : 431076, 435756, 7020086, 7030112 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## data source : e:/GIS/trevor/053575070010_01/053575070010_01_P001_MUL/14AUG19082006-M2AS-053575070010_01_P001.TIF ## names : X14AUG19082006.M2AS.053575070010_01_P001.7 ## values : 56, 1729 (min, max) ## ## ## [[8]] ## class : RasterLayer ## band : 8 (of 8 bands) ## dimensions : 5013, 2340, 11730420 (nrow, ncol, ncell) ## resolution : 2, 2 (x, y) ## extent : 431076, 435756, 7020086, 7030112 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## data source : e:/GIS/trevor/053575070010_01/053575070010_01_P001_MUL/14AUG19082006-M2AS-053575070010_01_P001.TIF ## names : X14AUG19082006.M2AS.053575070010_01_P001.8 ## values : 32, 1723 (min, max) plotRGB(dg.bands, r = 3, g = 2, b = 1, scale = 800, stretch = &quot;hist&quot;) b1 = raster(&quot;e:/bookdown/spatil_r/landsat_clip_2014/clip_LC81660652014164LGN00_B1.tif&quot;) b2 = raster(&quot;e:/bookdown/spatil_r/landsat_clip_2014/clip_LC81660652014164LGN00_B2.tif&quot;) b3 = raster(&quot;e:/bookdown/spatil_r/landsat_clip_2014/clip_LC81660652014164LGN00_B3.tif&quot;) b4 = raster(&quot;e:/bookdown/spatil_r/landsat_clip_2014/clip_LC81660652014164LGN00_B4.tif&quot;) b5 = raster(&quot;e:/bookdown/spatil_r/landsat_clip_2014/clip_LC81660652014164LGN00_B5.tif&quot;) b6 = raster(&quot;e:/bookdown/spatil_r/landsat_clip_2014/clip_LC81660652014164LGN00_B6.tif&quot;) b7 = raster(&quot;e:/bookdown/spatil_r/landsat_clip_2014/clip_LC81660652014164LGN00_B7.tif&quot;) stack(b1, b2, b3) %&gt;% plotRGB(r = 3, g = 2, b = 1, scale = TRUE) 2.6 Manipulate raster 2.7 Raster time series data 2.8 comparing NDVI from Two different sites References "],
["rasterv.html", "Chapter 3 Raster Visualization 3.1 visualize bathmetry with ggplot2 3.2 Convert data frame to bathmetric object", " Chapter 3 Raster Visualization 3.1 visualize bathmetry with ggplot2 loading the packages needed for this chapter require(sf) require(sp) require(raster) require(tidyverse) require(metR) Unlike the base plot function that plot raster dataset direct, to visualize raster data in R using the ggplot2 package, we need to convert the raster dataset into a data frame or tibble. The good thing is that raster has a as.data.frame() function that convert raster dataset into data frame. tz.bath.df = tz.bath %&gt;% raster::as.data.frame(xy = TRUE) %&gt;% as_tibble() tz.bath.df %&gt;% glimpse() ## Observations: 656,821 ## Variables: 3 ## $ x &lt;dbl&gt; 34.00000, 34.01667, 34.03333, 34.05000, 34.06667, ... ## $ y &lt;dbl&gt; 2.8e-06, 2.8e-06, 2.8e-06, 2.8e-06, 2.8e-06, 2.8e-... ## $ tanz1_.3432 &lt;int&gt; 1136, 1140, 1142, 1177, 1155, 1150, 1156, 1177, 11... Using the glimpse(), we notice that the file is the data frame with three variables of x,y and tangayink_dbm. we can change these variable names with the rename() function and change the depth values from decimal to integer. tz.bath.df = tz.bath.df %&gt;% rename(lon = x, lat = y, depth = 3)%&gt;% mutate(depth = as.integer(depth)) africa = st_read(&quot;e:/GIS/Tanzania spatial data Bank/EAF14 Tanzania spatial datasets/africa/Spatial/AdmInfr/afcntry.shp&quot;) ## Reading layer `afcntry&#39; from data source `e:\\GIS\\Tanzania spatial data Bank\\EAF14 Tanzania spatial datasets\\africa\\Spatial\\AdmInfr\\afcntry.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 59 features and 7 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -25.35875 ymin: -34.83983 xmax: 57.80085 ymax: 37.34962 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs tz = africa %&gt;% filter(CNTRY_NAME %in% c(&quot;Tanzania&quot;)) ggplot2 package developed and maintained by Wickham (2016) use the grammar of graphic to make plot. The nifty thing about this package is its ability to allow adding layers smoothly. For example in figure 3.1 is contour maps made from ggplot. This map shows the bathmetry just off the Kimbiji. From the contour label, we can see that the maximum depth is ~1200. The code for making this map is shown in the chunk below. Note that although ggplot2 has geom_contour() function, we used geom_contour2() function from metR package (Campitelli 2019). This is because the metR package has added tools that extend the plotting capabilities of ggplot2 package. For instance, there is no way you can label contour lines with ggplot2, but metR offers a geom_text_contour() that does the work. Furthermore, the geom_sf() and coord_sf() functions from sf package (Pebesma 2018) extend the mapping capabilities of ggplot. This set of geom, stat, and coord are used to visualise simple feature (sf) objects. For simple plots, you will only need geom_sf() as it uses stat_sf() and adds coord_sf() for you. Pebesma (2018) clearly mentioned that geom_sf() is an unusual geom because it draw different geometric objects (points, lines and polygon) depending on what simple features are present in the data. off.kimbiji = tz.bath.df %&gt;% filter(lon &gt; 38.5 &amp; lon &lt; 40 &amp; lat &gt; -7.2 &amp; lat &lt; - 6 &amp; depth &gt; -1200&amp; depth &lt; 0 ) ggplot()+ geom_sf(data = tz, fill = &quot;grey90&quot;, col = &quot;grey40&quot;)+ geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 50, col = &quot;grey&quot;)+ geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200)+ geom_text_contour(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200, rotate = FALSE)+ coord_sf(xlim = c(39.2, 39.8), ylim = c(-7, -6.3))+ theme_bw()+ theme(panel.background = element_rect(fill = &quot;white&quot;), panel.grid = element_line(colour = NA), axis.text = element_text(size = 11))+ scale_x_continuous(breaks = seq(39.2, 39.8, .2))+ scale_y_continuous(breaks = seq(-6.95, -6.35, length.out = 4))+ labs(x = NULL, y = NULL)+ annotate(geom = &quot;text&quot;, x = 39.28, y = -6.48, label = &quot;Zanzibar \\nChannel&quot;)+ annotate(geom = &quot;text&quot;, x = 39.5, y = -6.37, label = &quot;Unguja \\nIsland&quot;)+ annotate(geom = &quot;text&quot;, x = 39.3, y = -6.91, label = &quot;Dar es Salaam&quot;) Figure 3.1: Map of Off-Kimbiji showing contour lines. The grey lines are contour at 50 m interval and the black line are contoured at 200 m intervals We can also use the combination of geom_contour_fill() and geom_contour_tanaka() functions from metR package to make filled contours that are shaded as shown in figure 3.2. From the contour label, we can see that the maximum depth is ~1200. However, the filled contours clearly show the 100 m interval that are color coded with lighblue for shallow and darkblue for the deepest part. ggplot()+ geom_contour_fill(data = off.kimbiji, aes(x = lon, y = lat, z=depth), col = &quot;grey&quot;, na.fill = TRUE)+ geom_contour_tanaka(data = off.kimbiji, aes(x = lon, y = lat, z=depth))+ geom_text_contour(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200, rotate = FALSE)+ geom_sf(data = tz, fill = &quot;grey90&quot;, col = &quot;grey40&quot;)+ coord_sf(xlim = c(39.2, 39.8), ylim = c(-7, -6.3))+ theme_bw()+ theme(panel.background = element_rect(fill = &quot;white&quot;), panel.grid = element_line(colour = NA), axis.text = element_text(size = 11), legend.position = &quot;none&quot;)+ scale_x_continuous(breaks = seq(39.2, 39.8, .2))+ scale_y_continuous(breaks = seq(-6.95, -6.35, length.out = 4))+ scale_fill_continuous(name = &quot;Depth&quot;, breaks = seq(-1200,0, 200))+ labs(x = NULL, y = NULL)+ annotate(geom = &quot;text&quot;, x = 39.28, y = -6.48, label = &quot;Zanzibar \\nChannel&quot;)+ annotate(geom = &quot;text&quot;, x = 39.5, y = -6.37, label = &quot;Unguja \\nIsland&quot;)+ annotate(geom = &quot;text&quot;, x = 39.3, y = -6.91, label = &quot;Dar es Salaam&quot;) ## Warning: imputing missing values Figure 3.2: Map off-Kimbiji showing contour filled contour that are shaded with lines 3.2 Convert data frame to bathmetric object Pante and Simon-Bouhet (2013) developed marmap package which has tools relevant for working with spatial objects. For instance we are interested to see the topographical profiles along the red transect showin in figure 3.3. ## Parsed with column specification: ## cols( ## lon = col_double(), ## lat = col_double() ## ) ## Warning: imputing missing values Figure 3.3: Map off-Kimbiji showing contour filled contour that are shaded with lines The process involves two steps, first we need to convert the data frame layer of bathmetry into the class bathy, which is the matrix form using the marmap::as.bath() function. This function accept data a three-column data frame with longitude(x), latitude(y) and depth(z). Then we need the longitude and latitude positions of the transect, but rather than the matrix form it suppose to be in data.frame format. The chunk below highlight the process of converting three-column data frame into matrix of bath format. bath.mat = off.kimbiji%&gt;% as.data.frame() %&gt;% marmap::as.bathy() Then we import the file that containing the longitude and latiude information of the transect transect = read_csv(&quot;kimbiji_kizimkazi_transect.csv&quot;) ## Parsed with column specification: ## cols( ## lon = col_double(), ## lat = col_double() ## ) Once we have imported the transect location information and converted the three-column data frame into the bath format, we can now extract bathmetry information and save them as data frame using the marmap::get_depth() function as shown in the code block below and the extracted depth are presented in table 3.1. transect.depth = marmap::get.depth(mat = bath.mat, x = transect$lon, y = transect$lat, locator = FALSE) Table 3.1: Depth along the transect extracted from the bathmetry layer at each location Longitude Latitude Depth (m) 39.4534 -6.8509 -7 39.4534 -6.8227 -42 39.4675 -6.7873 -127 39.4746 -6.7590 -196 39.4781 -6.7307 -335 39.4923 -6.7130 -389 39.4852 -6.6953 -385 39.4923 -6.6600 -423 39.5064 -6.6458 -418 39.5170 -6.6317 -433 39.5206 -6.6140 -422 39.5276 -6.5786 -410 39.5276 -6.5574 -369 39.5347 -6.5397 -345 39.5418 -6.5185 -338 39.5453 -6.4973 -299 39.5453 -6.4831 -227 39.5524 -6.4619 -35 The topographical profile of the transect in figure 3.3 is presented in figure 3.4. You notice that the profile is u-shape with with zero depth at Kimbiji and reach a maximum depth of about 400 meter at about 6.66oS and then start ascending as you approach south tip of Unguja Island. ggplot(data = transect.depth, aes(x = lat, y = depth))+ geom_path(col = &quot;red&quot;, size = 1.2)+ theme(panel.background = element_rect(fill = &quot;white&quot;, colour = &quot;black&quot;), axis.text = element_text(size = 12, colour = 1), axis.title = element_text(size = 14, colour = 1))+ scale_x_continuous(breaks = seq(-6.9, -6.5, length.out = 6), labels = metR::LatLabel(seq(-6.9, -6.5, length.out = 6)))+ labs(x = NULL, y = &quot;Depth (m)&quot;) Figure 3.4: Topographic profile along the transec With an extended functionalites in cowplot package, we can combine plofts in a single figure, for instance figure 3.5 show the filled contour and an inset topographic plot on top. The figure 3.5 was created using the ggdraw() and draw_plot() functions from cowplot package (Wilke 2019) ## map map = ggplot()+ geom_contour_fill(data = off.kimbiji, aes(x = lon, y = lat, z=depth), col = &quot;grey&quot;, na.fill = TRUE)+ geom_contour_tanaka(data = off.kimbiji, aes(x = lon, y = lat, z=depth))+ geom_text_contour(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200, rotate = FALSE)+ geom_sf(data = tz, fill = &quot;grey90&quot;, col = &quot;grey40&quot;)+ geom_path(data = profile, aes(x = lon, y = lat), size = 2, col = &quot;red&quot;)+ coord_sf(xlim = c(39.2, 39.8), ylim = c(-7, -6.3))+ theme_bw()+ theme(panel.background = element_rect(fill = &quot;white&quot;), panel.grid = element_line(colour = NA), axis.text = element_text(size = 11), legend.position = &quot;none&quot;)+ scale_x_continuous(breaks = seq(39.2, 39.8, .2))+ scale_y_continuous(breaks = seq(-6.95, -6.35, length.out = 4))+ scale_fill_continuous(name = &quot;Depth&quot;, breaks = seq(-1200,0, 200))+ labs(x = NULL, y = NULL)+ annotate(geom = &quot;text&quot;, x = 39.28, y = -6.48, label = &quot;Zanzibar \\nChannel&quot;)+ # annotate(geom = &quot;text&quot;, x = 39.3, y = -6.91, label = &quot;Dar es Salaam&quot;)+ annotate(geom = &quot;text&quot;, x = 39.5, y = -6.37, label = &quot;Unguja \\nIsland&quot;) ## profile profile = ggplot(data = transect.depth, aes(x = lat, y = depth))+ geom_path(col = &quot;red&quot;, size = 1.2)+ theme(panel.background = element_rect(fill = &quot;white&quot;, colour = 1, size = 1), plot.background = element_rect(fill = NA, colour = NA), panel.grid = element_line(colour = NA), axis.text.x = element_text(size = 10, colour = &quot;black&quot;), axis.text.y = element_text(size = 10, colour = &quot;black&quot;), axis.title = element_text(size = 11, colour = 1))+ scale_x_continuous(breaks = c(-6.8,-6.5), labels = metR::LatLabel(c(-6.8,-6.5)))+ labs(x = NULL, y = &quot;&quot;) ## combine the bathmetry map and profile plot cowplot::ggdraw()+ cowplot::draw_plot(plot = map, x = 0, y = 0, width = 1, height = 1, scale = 1)+ cowplot::draw_plot(plot = profile, x = 0.27, y = 0.075, width = 0.22, height = 0.3) ## Warning: imputing missing values Figure 3.5: Map off-Kimbiji showing contour filled contour that are shaded with lines, an inset profile shows the topographical profile along the transect labeld with red References "],
["vector.html", "Chapter 4 Vector Data 4.1 Introduction 4.2 Vector Data 4.3 Reading vector data 4.4 Make shapefiles from Tabular data 4.5 Export simple feature as shapefile", " Chapter 4 Vector Data 4.1 Introduction This chapter provides brief explanations of the fundamental vector model. You will get familiar with the theory behind vector model and the disciplines in which they predominate, before demonstrating its implementation in R. 4.2 Vector Data The geographic vector model is based on points located within a coordinate reference system (CRS). Points can represent self-standing features (e.g., the locations where research sample were taken ) or they can be linked together to form complex geometries like lines and polygons. Most point geometries contain only two dimensions with longitude and latitude together with the attribute information. However 3-dimensional points contain an additional \\(z\\) value— representing a thrid dimension—elevation, bathmetry etc. The standard and widely implemented spatial format for vector data is shapefile. shapefile format is popular geospatial vector data format for geographical information system (GIS) software.It is developed and maintained by Esri. Despite what its name may imply, a “single” shapefile is actually composed of at least three files, and as many as eight. Each file that makes up a “shapefile” has a common filename but different extension type. The list of files that define a “shapefile” are shown in table 4.1. Note that each file has a specific role in defining a shapefile. Table 4.1: Eight Common files that makes a shapefile Description Extension Attribute information .dbf Feature geometry .shp Feature geometry index .shx Attribute index .aih Attribute index .ain Coordinate system information .prj Spatial index file .sbn Spatial index file .sbx Until recent, shapefile format was the de facto form ofvector data basis for libraries such as GDAL. R has well-supported classes for storing spatial data and interfacing to the shapefile format, but has so far lacked a complete implementation of simple features, making conversions at times convoluted, inefficient or incomplete (Pebesma 2018). 4.2.1 Simple features Pebesma (2018) plainly described simple features as hierachical data model that present objects in the real world in computers, with emphasis on the spatial geometry of these objects. Out of 17, there are only seven seven simple feature types described in Table 4.2 that are commonly used. sf can represent common vector geometry types—points, lines, polygons and their respective ‘multi’ versions. sf also supports geometry collections, which can contain multiple geometry types in a single object. Table 4.2: Common simple features Type Description Point zero-dimensional geometry containing a single point Linestring sequence of points connected by straight, non-self intersecting line pieces; one-dimensional geometry Polygon geometry with a positive area (two-dimensional); sequence of points form a closed, non-self intersecting ring; the first ring denotes the exterior ring, zero or more subsequent rings denote holes in this exterior ring Multipoint set of points; a MULTIPOINT is simple if no two Points in the MULTIPOINT are equal Multilinestring Set of linestrings Multipolygon set of polygons Geometrycollection Set of geometries of any type with exception of geometrycollection These core geometry types are fully supported by the R package sf (Pebesma 2018). sf is a package providing a class system for geographic vector data (Lovelace, Nowosad, and Muenchow 2019) supersede, sp—methods for spatial data (Bivand, Pebesma, and Gomez-Rubio 2013). It also provides a consistent command-line interface to GEOS and GDAL, superseding rgdal— for data read/write (Bivand, Keitt, and Rowlingson 2019) and rgeos—for spatial operations (Bivand and Rundel 2018) packages 4.3 Reading vector data We will use the sf package to work with vector data in R [Pebesma (2018). Notice that the rgdal package automatically loads when sf is loaded. The sf package has the st_read() function that read different types of vector data to sf object. require(sf) 4.3.1 Reading shapefiles Shapefile is the widely used vector format in GIS software. The function st_read() import any type of shapefile into R. for example the chunk block below show how to import the sampling location that are in shapefile format into simple feature object in R’s worksapace. location = st_read(&quot;location.shp&quot;) ## Reading layer `location&#39; from data source `E:\\bookdown\\spatil_r\\location.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 18 features and 1 field ## geometry type: POINT ## dimension: XY ## bbox: xmin: 39.45336 ymin: -6.850945 xmax: 39.55239 ymax: -6.461915 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs location ## Simple feature collection with 18 features and 1 field ## geometry type: POINT ## dimension: XY ## bbox: xmin: 39.45336 ymin: -6.850945 xmax: 39.55239 ymax: -6.461915 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## First 10 features: ## name geometry ## 1 station 1 POINT (39.45336 -6.850945) ## 2 station 2 POINT (39.45336 -6.822652) ## 3 station 3 POINT (39.46751 -6.787286) ## 4 station 4 POINT (39.47458 -6.758993) ## 5 station 5 POINT (39.47812 -6.7307) ## 6 station 6 POINT (39.49226 -6.713016) ## 7 station 7 POINT (39.48519 -6.695333) ## 8 station 8 POINT (39.49226 -6.659967) ## 9 station 9 POINT (39.50641 -6.64582) ## 10 station 10 POINT (39.51702 -6.631674) When we print the this simple feature it tells us that it has 18 features that span between longitude 39.45336°E and 39.55239°E and latitude 6.850945°S and 6.461915°S with defined geographical coordinate system of WGS84. 4.3.2 Reading GPX file The st_read() function can also read files from GPS devices with the .gpx extension. track = st_read(&quot;Track-180911-063740.gpx&quot;, quiet = TRUE) ## Warning in evalq((function (..., call. = TRUE, immediate. = FALSE, ## noBreaks. = FALSE, : automatically selected the first layer in a data ## source containing more than one. track ## Simple feature collection with 1 feature and 24 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 39.44527 ymin: -6.907095 xmax: 39.44527 ymax: -6.907095 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## ele time magvar geoidheight name cmt ## 1 14.4 2018-09-11 07:42:07 NA NA Track Recording Stopped &lt;NA&gt; ## desc ## 1 Recording stopped at 33&#39;00&quot; because the user stopped it after 6.58km (0.50m gain). ## src link1_href link1_text link1_type link2_href link2_text link2_type ## 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## sym type fix sat hdop vdop pdop ageofdgpsdata dgpsid x_speed ## 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA NA NA NA NA NA 0.385527 ## geometry ## 1 POINT (39.44527 -6.907095) We can assess the geographical extent of the simple feature track with the st_bbox() function. track %&gt;% st_bbox() ## xmin ymin xmax ymax ## 39.445274 -6.907095 39.445274 -6.907095 And check the type of geographical coordinate system with st_crs() function track %&gt;% st_crs() ## Coordinate Reference System: ## EPSG: 4326 ## proj4string: &quot;+proj=longlat +datum=WGS84 +no_defs&quot; 4.4 Make shapefiles from Tabular data Sometimes the geographical information are in tabular form and you need to convert them into simple feature to work with spatial analysis and mapping. The sf package provide a st_as_sf() function that can make simple feature from the location information in the table. To illustrate this point, let us first load the file that contain the geographical information into the workspace. location = read_csv(&quot;kimbiji_kizimkazi_transect.csv&quot;) ## Parsed with column specification: ## cols( ## lon = col_double(), ## lat = col_double() ## ) Looking the internal structure of the location object we loaded, we find that there are eighteen observations and each observation has the longitude and latitude information. location %&gt;% glimpse() ## Observations: 18 ## Variables: 2 ## $ lon &lt;dbl&gt; 39.45336, 39.45336, 39.46751, 39.47458, 39.47812, 39.49226... ## $ lat &lt;dbl&gt; -6.850945, -6.822652, -6.787286, -6.758993, -6.730700, -6.... The file contain only the geographical information. We can add the column for station names. mutate() function from dplyr package add the third column. Because the station name should be sequentially numbered, the paste() function was used to do this. location = location %&gt;% mutate(name = paste(&quot;station&quot;, 1:18)) Once we know that the dataset contain the longitude and latitude information, we can use these spatial information to make simple feature object using the st_as_sf() from sf package location.sf = location %&gt;% st_as_sf(coords = c(&quot;lon&quot;, &quot;lat&quot;)) location.sf ## Simple feature collection with 18 features and 1 field ## geometry type: POINT ## dimension: XY ## bbox: xmin: 39.45336 ymin: -6.850945 xmax: 39.55239 ymax: -6.461915 ## epsg (SRID): NA ## proj4string: NA ## # A tibble: 18 x 2 ## name geometry ## &lt;chr&gt; &lt;POINT&gt; ## 1 station 1 (39.45336 -6.850945) ## 2 station 2 (39.45336 -6.822652) ## 3 station 3 (39.46751 -6.787286) ## 4 station 4 (39.47458 -6.758993) ## 5 station 5 (39.47812 -6.7307) ## 6 station 6 (39.49226 -6.713016) ## 7 station 7 (39.48519 -6.695333) ## 8 station 8 (39.49226 -6.659967) ## 9 station 9 (39.50641 -6.64582) ## 10 station 10 (39.51702 -6.631674) ## 11 station 11 (39.52056 -6.61399) ## 12 station 12 (39.52763 -6.578624) ## 13 station 13 (39.52763 -6.557404) ## 14 station 14 (39.5347 -6.539721) ## 15 station 15 (39.54178 -6.518501) ## 16 station 16 (39.54531 -6.497281) ## 17 station 17 (39.54531 -6.483135) ## 18 station 18 (39.55239 -6.461915) The coords parameter is given the latitude and longitude value columns–values used to locate the points associated with each record. We now have a simple featuere with 18 points. However, the simple feature lack the coordinate system. We can define the coordinate system for the simple feature with the st_set_crs() function and parse the epsg code of WGS84. location.sf = location.sf %&gt;% st_set_crs(4326) Let us check if the location.sf is indeed a spatial object location.sf ## Simple feature collection with 18 features and 1 field ## geometry type: POINT ## dimension: XY ## bbox: xmin: 39.45336 ymin: -6.850945 xmax: 39.55239 ymax: -6.461915 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## # A tibble: 18 x 2 ## name geometry ## &lt;chr&gt; &lt;POINT [Â°]&gt; ## 1 station 1 (39.45336 -6.850945) ## 2 station 2 (39.45336 -6.822652) ## 3 station 3 (39.46751 -6.787286) ## 4 station 4 (39.47458 -6.758993) ## 5 station 5 (39.47812 -6.7307) ## 6 station 6 (39.49226 -6.713016) ## 7 station 7 (39.48519 -6.695333) ## 8 station 8 (39.49226 -6.659967) ## 9 station 9 (39.50641 -6.64582) ## 10 station 10 (39.51702 -6.631674) ## 11 station 11 (39.52056 -6.61399) ## 12 station 12 (39.52763 -6.578624) ## 13 station 13 (39.52763 -6.557404) ## 14 station 14 (39.5347 -6.539721) ## 15 station 15 (39.54178 -6.518501) ## 16 station 16 (39.54531 -6.497281) ## 17 station 17 (39.54531 -6.483135) ## 18 station 18 (39.55239 -6.461915) let us check the class of the simple feature location.sf %&gt;% class() ## [1] &quot;sf&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Note the object has four class sf, tbl_df, tbl, and data_frame. The data frame contents was also carried over into the attributes table of the simple feature. There was only one attribute, name, other than lon and lat in the tabular data used to create this simple feature. Looking on the file clearly the projection is defined to WGS84. We can further transform the geographical coordinate system that is degree into the UTM, which is in metric. The function st_transform() from sf package handle transformation of coordinate system (Pebesma 2018). The epsg code for zone 37 south is 32737, which is parsed into the function. location.utm = location.sf %&gt;% st_transform(32737) location.utm ## Simple feature collection with 18 features and 1 field ## geometry type: POINT ## dimension: XY ## bbox: xmin: 550090.3 ymin: 9242705 xmax: 561079.7 ymax: 9285701 ## epsg (SRID): 32737 ## proj4string: +proj=utm +zone=37 +south +datum=WGS84 +units=m +no_defs ## # A tibble: 18 x 2 ## name geometry ## &lt;chr&gt; &lt;POINT [m]&gt; ## 1 station 1 (550090.3 9242705) ## 2 station 2 (550093.2 9245833) ## 3 station 3 (551660.2 9249741) ## 4 station 4 (552444.8 9252868) ## 5 station 5 (552838.7 9255995) ## 6 station 6 (554404.1 9257949) ## 7 station 7 (553624.3 9259904) ## 8 station 8 (554410 9263813) ## 9 station 9 (555975.3 9265376) ## 10 station 10 (557149.7 9266938) ## 11 station 11 (557542.7 9268893) ## 12 station 12 (558328.7 9272802) ## 13 station 13 (558331.2 9275147) ## 14 station 14 (559115.3 9277101) ## 15 station 15 (559899.8 9279446) ## 16 station 16 (560293.4 9281792) ## 17 station 17 (560295.1 9283356) ## 18 station 18 (561079.7 9285701) 4.5 Export simple feature as shapefile Once the simple feature is created, you might be interested to export as shapefile for use with other GIS software like QGIS and Esri ARCGIS. The sf package has a st_write() function that export simple feature from the workspace into shapefiles in the working directory. The chunk block below demonstrates the export of simple feature object location.sf into the location.shp in the working directory—denoted with ./ location.sf %&gt;% st_write(&quot;./location.shp&quot;) References "],
["graphics.html", "Chapter 5 Making Maps 5.1 Introduction 5.2 Creating a ggplot 5.3 Inset maps 5.4 Static Maps 5.5 Animated maps 5.6 Interactive maps", " Chapter 5 Making Maps 5.1 Introduction Now that you understand vector and raster data model in spatial context, you need to communicate your understanding to others. A satisfying and important aspect of geographic research is communicating the results. To help others quickly build up a good mental model of the spatial data, you will need to invest considerable effort in making your maps as self-explanatory as possible. In this chapter, you’ll learn some of the tools that ggplot2 provides to make elegand maps and graphics (Wickham 2016). R has several systems for making graphs, but ggplot2 is one of the most elegant and most versatile. ggplot2 implements the grammar of graphics, a coherent system for describing and building graphs. The chapter also introduce you to some extended functionalities from sf (Pebesma 2018), cowplot (Wilke 2019), ggsn (Santos Baquero 2019), ggsci (Xiao 2018), metR (Campitelli 2019), ggrepel (Slowikowski 2018), gganimate (Pedersen and Robinson 2019) and egg (Auguie 2018) packages. Therefore, this chapter focuses on the tools you need to create good graphics. Rather than loading those extensions here, we’ll refer to their functions explicitly, using the :: notation. This will help make it clear which functions are built into ggplot2, and which come from other packages. Ensure you have these packages in your machine, otherwise install them with install.packages() if you don’t already have them. require(tidyverse) Let us make a map showing contour off–Kimbiji located between longitude 38.5°E and 40.1°E and latitude 7.2°S and `r LatLabel(-6.0). We need to create map of figure 5.1, which was created with ggplot2. But, we will go step by step until we arrive to to an elegant map like figure 5.1. Figure 5.1: Map of Off-Kimbiji showing contour lines. The grey lines are contour at 50 m interval and the black line are contoured at 200 m intervals 5.1.1 The bathmetry data ggplot2 works with data that are tidy—data frame arranged in such way that observations are in rows and variables are in columns and each value must have its own cell. But, the bathmetry data is from ETOPO1 and came as .asc. We first read the file with the raster::raster() function.Once the raster is in the worksapce, we use theraster::as.data.frame(xy = TRUE)and supply thexy = TRUE` argument to convert raster object to data frame. We then tidy the data frame with rename() and mutate() and filter() function ## read the ascii file tz.bath = raster::raster(&quot;e:/GIS/ROADMAP/Etopo 1/Tanzania_etopo1/tanz1_-3432.asc&quot;) ## convert raster to data frame tz.bath.df = tz.bath %&gt;% raster::as.data.frame(xy = TRUE) %&gt;% dplyr::as_tibble() ## rename the variable tz.bath.df = tz.bath.df %&gt;% dplyr::rename(lon = x, lat = y, depth = 3)%&gt;% dplyr::mutate(depth = as.integer(depth)) ## chop the area of interest off.kimbiji = tz.bath.df %&gt;% dplyr::filter(lon &gt; 38.5 &amp; lon &lt; 40 &amp; lat &gt; -7.2 &amp; lat &lt; - 6 &amp; depth &gt; -1200&amp; depth &lt; 0 ) The bathmetry file now contain three variables, the lon, lat and depth (Table 5.1) off.kimbiji %&gt;% dplyr::sample_n(5) %&gt;% knitr::kable(col.names = c(&quot;Longitude&quot;, &quot;Latitude&quot;, &quot;Depth (meters)&quot;), digits = 3, caption = &quot;The rectangular data frame consist of bathmetry of Kimbiji&quot;)%&gt;% kableExtra::column_spec(column = 3, width = &quot;3cm&quot;) Table 5.1: The rectangular data frame consist of bathmetry of Kimbiji Longitude Latitude Depth (meters) 39.617 -6.283 -186 39.333 -6.367 -1 39.667 -6.450 -486 39.183 -6.133 -1 38.800 -6.083 -2 We also need basemap—country boundary layer. We use the st_read() function from sf package to read the shapefile boundary layer. Since the layer is for Africa, we use the st_crop() function to chop the area of interest. this is important as it reduce processing time africa = st_read(&quot;e:/GIS/Tanzania spatial data Bank/EAF14 Tanzania spatial datasets/africa/Spatial/AdmInfr/afcntry.shp&quot;) ## Reading layer `afcntry&#39; from data source `e:\\GIS\\Tanzania spatial data Bank\\EAF14 Tanzania spatial datasets\\africa\\Spatial\\AdmInfr\\afcntry.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 59 features and 7 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -25.35875 ymin: -34.83983 xmax: 57.80085 ymax: 37.34962 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs kimbiji = africa %&gt;% st_crop(xmin = 38.0, xmax = 40.5, ymin = -8, ymax = -5.5) ## although coordinates are longitude/latitude, st_intersection assumes that they are planar ## Warning: attribute variables are assumed to be spatially constant ## throughout all geometries 5.2 Creating a ggplot To plot the contour map, run this code to put lon on the x–axis and lat on the y–axis ggplot(data = off.kimbiji)+ geom_contour(mapping = aes(x = lon, y = lat, z = depth)) Figure 5.2: Contour lines of coastal water off-Kimbiji Figure 5.2 shows bathmetry presented as contour lines. With ggplot2, you can begin a plot with the function ggplot(), which create a coordinate system that you can add layers to. The first arguments of ggplot() is the dataset to use in plot. So ggplot(data = off.kimbiji) creates an empty plot. You complete the graph by adding one or more layers to the ggplot(). The geom_contour() adds a layer of contour lines. ggplot2 comes with many geom that each add a different type of layer to a plot. Each geom function in ggplot2 takes a mapping argument, which defines how variable in your dataset are mapped. The mapping argument is always paired with aes(), and the x and y arguments of aes() specify which variable to map on the x and y axes. **ggplot2 looks for the mapped variables in the data argument, in this case the off-kimbiji. 5.2.1 Label Graph need good label, we can improve figure 5.2 by adding label on the map with the labs() function.This example adds a title to figure 5.3 ggplot(data = off.kimbiji)+ geom_contour(mapping = aes(x = lon, y = lat, z = depth))+ labs(title = &quot;Contour lines off Kimbiji&quot;) Figure 5.3: Contour lines of coastal water off-Kimbiji The labs() function also allows you to add x and y labels as in figure 5.4 ggplot(data = off.kimbiji)+ geom_contour(mapping = aes(x = lon, y = lat, z = depth))+ labs(title = &quot;Contour lines off Kimbiji&quot;, x = &quot;Longitude&quot;, y = &quot;Latitude&quot;) Figure 5.4: Contour lines of coastal water off-Kimbiji 5.2.2 Annotations In addition to labs() function that allows to easy place label on map, ggplot2 has a geom_text() function, which allows to add textual label on the plots. Similar to geom_point() function that has x and y argument, but the geom_text() has additional argument— label. This function is useful especially if you want to place station name on the map or plot. The function requires the data in form of data frame. Therefore we first create a data frame that contains lon, lat and site using the tibble() function. The chunk below illustrates the use of geom_point() and geom_text() as was used to make figure 5.5 ## make data frame of three stations stations = tibble(lon = c(39.5, 39.7, 39.5), lat = c(-7.1, -6.75, -6.25), site = paste(&quot;st&quot;,101:103, sep = &quot;&quot;)) ggplot(data = off.kimbiji)+ geom_contour(mapping = aes(x = lon, y = lat, z = depth))+ labs(title = &quot;Contour lines off Kimbiji&quot;, x = &quot;Longitude&quot;, y = &quot;Latitude&quot;)+ geom_point(data = stations, aes(x = lon, y = lat))+ geom_text(data = stations, aes(x = lon, y = lat, label = site)) Figure 5.5: Contour lines of coastal water off-Kimbiji Although the geom_text() does the right thing of placing the textual label on plot or maps, it requires some adjustment to make the label on the right position and not on top of a point and ggplot2 provides those tools. Alternatively, you can use an extended ggrepel::geom_text_repel() function from ggrepel package (Slowikowski 2018). geom_text_repel()` function place the label in the right position and requires no addition tweeking as the label in figure 5.6. ggplot(data = off.kimbiji)+ geom_contour(mapping = aes(x = lon, y = lat, z = depth))+ labs(title = &quot;Contour lines off Kimbiji&quot;, x = &quot;Longitude&quot;, y = &quot;Latitude&quot;)+ geom_point(data = stations, aes(x = lon, y = lat))+ ggrepel::geom_text_repel(data = stations, aes(x = lon, y = lat, label = site)) Figure 5.6: Contour lines of coastal water off-Kimbiji Unfortunate, neither geom_text() nor ggrepel::geom_text_repel() work with label that are not in the data frame. In that situation, you can use the annoation() function that does the job. The code below was used to make figure 5.7 ggplot(data = off.kimbiji)+ geom_contour(mapping = aes(x = lon, y = lat, z = depth))+ labs(title = &quot;Contour lines off Kimbiji&quot;, x = &quot;Longitude&quot;, y = &quot;Latitude&quot;)+ geom_point(data = stations, aes(x = lon, y = lat))+ ggrepel::geom_text_repel(data = stations, aes(x = lon, y = lat, label = site))+ annotate(geom = &quot;text&quot;, x = 39.6, y = -6.65, label = &quot;INDIAN OCEAN&quot;) Figure 5.7: Contour lines of coastal water off-Kimbiji 5.2.3 Scales The other useful functions for making plot that help communicate clearly are scales. Although ggplot2 does the scaling for you, but sometimes you may need to adjust the mapping from the data values to make a plot or map more appealing (figure 5.8 ). ggplot(data = off.kimbiji) + geom_contour(mapping = aes(x = lon, y = lat, z = depth))+ labs(title = &quot;Contour lines off Kimbiji&quot;, x = &quot;Longitude&quot;, y = &quot;Latitude&quot;) + geom_point(data = stations, aes(x = lon, y = lat))+ ggrepel::geom_text_repel(data = stations, aes(x = lon, y = lat, label = site)) + annotate(geom = &quot;text&quot;, x = 39.6, y = -6.65, label = &quot;INDIAN OCEAN&quot;)+ scale_x_continuous() + scale_y_continuous() Figure 5.8: Contour lines of coastal water off-Kimbiji. adding scales automatic You can adjust the these scales to your preference as in figure 5.9. Most scales have breaks and labels as primary arguments. ggplot(data = off.kimbiji) + geom_contour(mapping = aes(x = lon, y = lat, z = depth))+ labs(title = &quot;Contour lines off Kimbiji&quot;, x = &quot;Longitude&quot;, y = &quot;Latitude&quot;) + geom_point(data = stations, aes(x = lon, y = lat))+ ggrepel::geom_text_repel(data = stations, aes(x = lon, y = lat, label = site)) + annotate(geom = &quot;text&quot;, x = 39.6, y = -6.65, label = &quot;INDIAN OCEAN&quot;)+ scale_x_continuous(breaks = seq(39.35,39.95, length.out = 4)) + scale_y_continuous(breaks = seq(-7.15, -6.15, length.out = 4), labels = c(-7.15, -6.81, -6.48, -6.15)) Figure 5.9: Contour lines of coastal water off-Kimbiji. Adjust scales automatic For inset maps scales are often supressed. This is easily done in the scale by assigning labels = NULL. The chunk block below demonstrate the axis label suppresion that was used to make figure 5.10 ggplot(data = off.kimbiji) + geom_contour(mapping = aes(x = lon, y = lat, z = depth))+ labs(title = &quot;Contour lines off Kimbiji&quot;, x = &quot;Longitude&quot;, y = &quot;Latitude&quot;) + geom_point(data = stations, aes(x = lon, y = lat))+ ggrepel::geom_text_repel(data = stations, aes(x = lon, y = lat, label = site)) + annotate(geom = &quot;text&quot;, x = 39.6, y = -6.65, label = &quot;INDIAN OCEAN&quot;)+ scale_x_continuous(breaks = seq(39.35,39.95, length.out = 4), labels = NULL) + scale_y_continuous(breaks = seq(-7.15, -6.15, length.out = 4), labels = NULL) Figure 5.10: Contour lines of coastal water off-Kimbiji. Adjust scales and supress the labels ###Themes Themes in ggplot2 control the non-data parts of the plot. There quiet number of themes in ggplot2 and extended ones from ggthemes package (Arnold 2019). themes are widely and can be used to control legend position with legend.position arguments. They also control the display. For more information about the themes I recommend you taking time to read chapter 28 of the book titled R for data science written by Hadley Wickham. 5.2.4 Zooming Although you may have the region extent of your data, but often times you may wish to adjust the plotted area to your interest. If you want to achieve an equal dize of x- and y-axis, then add the coord_equal() function as layer on the ggplot(). The code in the chunk below was used to make figure 5.11 ggplot(data = off.kimbiji) + geom_contour(mapping = aes(x = lon, y = lat, z = depth))+ labs(title = &quot;Contour lines off Kimbiji&quot;, x = &quot;Longitude&quot;, y = &quot;Latitude&quot;) + geom_point(data = stations, aes(x = lon, y = lat))+ ggrepel::geom_text_repel(data = stations, aes(x = lon, y = lat, label = site)) + annotate(geom = &quot;text&quot;, x = 39.6, y = -6.65, label = &quot;INDIAN OCEAN&quot;)+ scale_x_continuous(breaks = seq(39.35,39.95, length.out = 4)) + scale_y_continuous(breaks = seq(-7.15, -6.15, length.out = 4), labels = c(-7.15, -6.81, -6.48, -6.15)) + coord_equal() Figure 5.11: Contour lines of coastal water off-Kimbiji. Equal zooming However, close look of figure 5.10 clearly show that the contour lines do not cross the plot margin. This requires zooming further inside of the ploting area. The function coord_cartesion() can adjust the zooming. This function allows you to set the limits of x-axis with xlim and y-axis with ylim arguments. Figure 5.12 was generated using the chunk below, which control the limits of the axis. ggplot(data = off.kimbiji) + geom_contour(mapping = aes(x = lon, y = lat, z = depth))+ labs(title = &quot;Contour lines off Kimbiji&quot;, x = &quot;Longitude&quot;, y = &quot;Latitude&quot;) + geom_point(data = stations, aes(x = lon, y = lat))+ ggrepel::geom_text_repel(data = stations, aes(x = lon, y = lat, label = site)) + annotate(geom = &quot;text&quot;, x = 39.6, y = -6.65, label = &quot;INDIAN OCEAN&quot;)+ scale_x_continuous(breaks = seq(39.35,39.95, length.out = 4)) + scale_y_continuous(breaks = seq(-7.15, -6.15, length.out = 4), labels = c(-7.15, -6.81, -6.48, -6.15)) + coord_cartesian(xlim = c(39.34, 39.95), ylim = c(-7.15, -6.15)) Figure 5.12: Contour lines of coastal water off-Kimbiji. Specify zooming Now after the abbove illustration that teach you the key functions ggplot2 offers for making elegant plots and maps, you can use the following code chunk to make figure 5.1. I will explain each line in the chunk. As before, you start plotting with ggplot2 with the ggplot() function. The second line of gode add a simple feature with a geom_sf() function from sf package. When mapping with geom_sf() function in ggplot2 package, you are advised to leave the ggplot() function empty. This will allow the geom_sf() to label the axes with the appropriate geographical labelling for longitude and latitude. Note however, I have instructed the geom_sf() to fill the boundary layer with grey of 90 shade and the stroke with black coloou. ggplot()+ geom_sf(data = kimbiji, fill = &quot;grey90&quot;, col = &quot;grey40&quot;) note that ggplot2 plot the map with default aesthetic settings. The plot background is filled with gray color and without stroke but the grids are white colored. The third line add the contour lines spaced at 50 meter intervals. Instead of using geom_contour() from ggplot2, the geom_contour2() from metR package was used. They both serve the same task. ggplot()+ geom_sf(data = kimbiji, fill = &quot;grey90&quot;, col = &quot;grey40&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 50, col = &quot;grey&quot;) Like the third line, the fourth line add contour lines, but instead of spacing them into meters, these are spaced at 200 meters interval and are black in color. ggplot()+ geom_sf(data = kimbiji, fill = &quot;grey90&quot;, col = &quot;grey40&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 50, col = &quot;grey&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200) The fifth line add the label on contour spaced at 200 meter interval with geom_text_contour() function from metR package. Here is where you will find the useful of package like metR that extends the ggplot2, for which the current version (2.3.1.1) is unable. ggplot()+ geom_sf(data = kimbiji, fill = &quot;grey90&quot;, col = &quot;grey40&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 50, col = &quot;grey&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200)+ metR::geom_text_contour(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200, rotate = FALSE) The sixth line zoom the map to only the geographical extent we are interested with using the coord_sf() function from sf package. We could also use the coord_cartesin() to limit the area. ggplot()+ geom_sf(data = kimbiji, fill = &quot;grey90&quot;, col = &quot;grey40&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 50, col = &quot;grey&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200)+ metR::geom_text_contour(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200, rotate = FALSE)+ coord_sf(xlim = c(39.2, 39.8), ylim = c(-7, -6.3)) We got a glimpse of the map now, let us use theme to make some changes. The background was set to white with panel.background = element_rect(fill = \"white\"), and removed grids with panel.grid = element_line(colour = NA) and change the font size of the axis label to 11 points with axis.text = element_text(size = 11). The theme_bw() just set the border of the plot to black with solid line. ggplot()+ geom_sf(data = kimbiji, fill = &quot;grey90&quot;, col = &quot;grey40&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 50, col = &quot;grey&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200)+ metR::geom_text_contour(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200, rotate = FALSE)+ coord_sf(xlim = c(39.2, 39.8), ylim = c(-7, -6.3))+ theme_bw()+ theme(panel.background = element_rect(fill = &quot;white&quot;), panel.grid = element_line(colour = NA), axis.text = element_text(size = 11)) By increasing the font size of axis textual label to 11, the axes are cluttered. adding the scale can improve the labelling. scale_x_continuous(breaks = seq(39.2, 39.8, .2)) in line 9 force ggplot2 to label the x–axis four letter that are spaced with 0.2 latitude and scale_y_continuous(breaks = seq(-6.95, -6.35, length.out = 4)) in line 10 label four digits of longitude. ggplot()+ geom_sf(data = kimbiji, fill = &quot;grey90&quot;, col = &quot;grey40&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 50, col = &quot;grey&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200)+ metR::geom_text_contour(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200, rotate = FALSE)+ coord_sf(xlim = c(39.2, 39.8), ylim = c(-7, -6.3))+ theme_bw()+ theme(panel.background = element_rect(fill = &quot;white&quot;), panel.grid = element_line(colour = NA), axis.text = element_text(size = 11))+ scale_x_continuous(breaks = seq(39.2, 39.8, .2))+ scale_y_continuous(breaks = seq(-6.95, -6.35, length.out = 4)) Because the axes are abbreviated with longitude and latitude symbol, line 11 in the code remove the axes title label. Line 12 to 14 add textual label on the map with the annotate() function. ggplot()+ geom_sf(data = kimbiji, fill = &quot;grey90&quot;, col = &quot;grey40&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 50, col = &quot;grey&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200)+ metR::geom_text_contour(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200, rotate = FALSE)+ coord_sf(xlim = c(39.2, 39.8), ylim = c(-7, -6.3))+ theme_bw()+ theme(panel.background = element_rect(fill = &quot;white&quot;), panel.grid = element_line(colour = NA), axis.text = element_text(size = 11))+ scale_x_continuous(breaks = seq(39.2, 39.8, .2))+ scale_y_continuous(breaks = seq(-6.95, -6.35, length.out = 4))+ labs(x = NULL, y = NULL)+ annotate(geom = &quot;text&quot;, x = 39.28, y = -6.48, label = &quot;Zanzibar \\nChannel&quot;)+ annotate(geom = &quot;text&quot;, x = 39.5, y = -6.37, label = &quot;Unguja \\nIsland&quot;)+ annotate(geom = &quot;text&quot;, x = 39.3, y = -6.91, label = &quot;Dar es Salaam&quot;) The last line of our code add the legend on the map using the scalebar() function from ggsn package (Santos Baquero 2019). In a nutshell, making this map using ggplot2 and ancillary extensions used fiften line codes and hundred of arguments. ggplot()+ geom_sf(data = kimbiji, fill = &quot;grey90&quot;, col = &quot;grey40&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 50, col = &quot;grey&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200)+ metR::geom_text_contour(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200, rotate = FALSE)+ coord_sf(xlim = c(39.2, 39.8), ylim = c(-7, -6.3))+ theme_bw()+ theme(panel.background = element_rect(fill = &quot;white&quot;), panel.grid = element_line(colour = NA), axis.text = element_text(size = 11))+ scale_x_continuous(breaks = seq(39.2, 39.8, .2))+ scale_y_continuous(breaks = seq(-6.95, -6.35, length.out = 4))+ labs(x = NULL, y = NULL)+ annotate(geom = &quot;text&quot;, x = 39.28, y = -6.48, label = &quot;Zanzibar \\nChannel&quot;)+ annotate(geom = &quot;text&quot;, x = 39.5, y = -6.37, label = &quot;Unguja \\nIsland&quot;)+ annotate(geom = &quot;text&quot;, x = 39.3, y = -6.91, label = &quot;Dar es Salaam&quot;)+ ggsn::scalebar(location = &quot;bottomleft&quot;, x.min = 39.2, x.max = 39.8, y.min = -6.98, y.max = -6.35, dist = 15, dist_unit = &quot;km&quot;, transform = TRUE, model = &quot;WGS84&quot;, st.dist = 0.03, st.size = 4, height = 0.03) 5.3 Inset maps An inset map is a smaller map rendered within or next to the main map. It could serve many different purposes, including showing the relative position of the study area in regional area. In figure 5.13 is the map showing the contour interval off-kimbiji, Tanzania. The inset map show the area of Kimbiji in the Western Indian Ocean Region. The chunk below was used to create figure 5.13. In a nutshell, we assign the study area map as main.map and the regional map as inset.map and then we used function from the cowplot package to combine the two maps. main.map = ggplot()+ geom_sf(data = kimbiji, fill = &quot;grey90&quot;, col = &quot;grey40&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 50, col = &quot;grey&quot;)+ metR::geom_contour2(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200)+ metR::geom_text_contour(data = off.kimbiji, aes(x = lon, y = lat, z=depth), binwidth = 200, rotate = FALSE)+ coord_sf(xlim = c(39.2, 39.8), ylim = c(-7, -6.3))+ theme_bw()+ theme(panel.background = element_rect(fill = &quot;white&quot;), panel.grid = element_line(colour = NA), axis.text = element_text(size = 11))+ scale_x_continuous(breaks = seq(39.2, 39.8, .2))+ scale_y_continuous(breaks = seq(-6.95, -6.35, length.out = 4))+ labs(x = NULL, y = NULL)+ annotate(geom = &quot;text&quot;, x = 39.28, y = -6.48, label = &quot;Zanzibar \\nChannel&quot;)+ annotate(geom = &quot;text&quot;, x = 39.5, y = -6.37, label = &quot;Unguja \\nIsland&quot;)+ annotate(geom = &quot;text&quot;, x = 39.3, y = -6.91, label = &quot;Dar es Salaam&quot;)+ ggsn::scalebar(location = &quot;bottomleft&quot;, x.min = 39.2, x.max = 39.8, y.min = -6.98, y.max = -6.35, dist = 15, dist_unit = &quot;km&quot;, transform = TRUE, model = &quot;WGS84&quot;, st.dist = 0.03, st.size = 4, height = 0.03) world = spData::world aoi = data.frame(lon = c(38.5, 40, 40, 38.5, 38.5), lat = c(-8, -8, -6, -6, -8)) inset.map = ggplot()+ geom_sf(data = world, fill = &quot;grey90&quot;, col = 1)+ coord_sf(xlim = c(37, 45), ylim = c(-12,-1))+ geom_path(data = aoi, aes(x = lon, y = lat), size = 1.2)+ theme_bw()+ theme(plot.background = element_blank(), axis.text = element_blank(), axis.ticks = element_blank(), panel.grid = element_line(colour = &quot;white&quot;)) + labs(x = NULL, y = NULL) cowplot::ggdraw()+ cowplot::draw_plot(plot = main.map, x = 0, y = 0, width = 1, height = 1, scale = 1)+ cowplot::draw_plot(plot = inset.map, x = .558, y = .05, width = .3,height = .3) Figure 5.13: The main map with the inset map showing the positon of the study areas in the region 5.4 Static Maps Static maps are the most common type of visual output from spatial objects. Fixed images for printed outputs, common formats for static maps include .png and .pdf, for raster and vector outputs, respectively. Initially static maps were the only type of map that R could produce. Things have advanced greatly since sp was released (see Bivand, Pebesma, and Gomez-Rubio (2013)). Many new techniques for map making have been developed since then. However, a decade later static plotting was still the emphasis of geographic data visualisation in R (Cheshire and Lovelace 2015). Despite the innovation of interactive mapping in R, static maps are still the foundation of mapping in R. The base plot() function is often the fastest way to create static maps from vector and raster spatial objects. Sometimes simplicity and speed are priorities, especially during the development phase of a project, and this is where plot() excels. The base R approach is also extensible, with plot() offering dozens of arguments. Another low-level approach is the grid package, which provides functions for low-level control of graphical outputs. This section, however, focus on how to make static maps with ggplot2, emphasizing the important aesthetic and layout options. 5.4.1 Map elements The good thing to start making maps is with an understanding of the map elements. A static map can be composed of many different map elements. These include main map body, legend, title, scale indicator, orientation indicator, inset map and source or ancillary information. The easiest place to start when turning an exploratory graphic into an expository graphic is with good labels. You add labels with the labs() function. This example adds a plot title: 5.5 Animated maps 5.6 Interactive maps References "],
["final-words.html", "Chapter 6 Final Words", " Chapter 6 Final Words We have finished a nice book. "],
["references.html", "References", " References "]
]
